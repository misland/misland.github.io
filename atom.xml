<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>暖宝宝官方认证铲屎官</title>
  
  
  <link href="https://misland.github.io/atom.xml" rel="self"/>
  
  <link href="https://misland.github.io/"/>
  <updated>2021-02-24T09:28:40.973Z</updated>
  <id>https://misland.github.io/</id>
  
  <author>
    <name>李洛</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ffmpeg第4篇：为视频添加动态水印</title>
    <link href="https://misland.github.io/2021/02/24/ffmpeg-watermark-2/"/>
    <id>https://misland.github.io/2021/02/24/ffmpeg-watermark-2/</id>
    <published>2021-02-24T08:20:21.000Z</published>
    <updated>2021-02-24T09:28:40.973Z</updated>
    
    <content type="html"><![CDATA[<p>动态分为三种：</p><ul><li>水印本身变化</li><li>水印显示时间变化</li><li>水印位置变化</li></ul><h2 id="水印本身变化"><a href="#水印本身变化" class="headerlink" title="水印本身变化"></a>水印本身变化</h2><p>看过<a href="http://localhost:4000/2021/02/23/ffmpeg-watermark-1/"><em>上一篇</em></a>的小伙伴可能觉得第一种很简单，把jpg格式的图片换成gif格式的不就可以了吗，然而亲自试一下就会发现，把gif图片当水印加上去后，图片播放一遍就不会动了。<br>之所以会这样是因为在ffmpeg中，水印的<code>eof_action</code>选项默认为<code>repeat</code>(参考<a href="https://ffmpeg.org/ffmpeg-filters.html#overlay-1"><em>这里</em></a>)，而<code>repeat</code>的作用是重复最后一帧，这就是为什么gif图片播放一遍就不动了的原因。</p><p>要解决这个问题，有两种方式，第一种是设置gif的<code>-ignore_loop</code>为0，让gif保持循环播放即可，命令如下：<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -filter_complex  overlay -shortest out.mp4 -y</code><br>但是这种方式，只适用于gif格式的图像，如果滤镜是一小段视频就无能为力了。</p><p>第二种解决方案是使用movie滤镜，同样是让gif循环播放，虽然这种方式复杂点，不过这种解决方案支持视频水印，命令如下：<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -vf &quot;movie=doggie3.gif:loop=0,setpts=N/FRAME_RATE/TB[out];[0:v][out]overlay=x=main_w-overlay_w:y=0&quot; -shortest out.mp4 -y</code><br>上面的命令有两个地方比较关键：</p><ul><li><code>loop=0,setpts=N/FRAME_RATE/TB</code> ：设置水印gif无限循环</li><li><code>-shortest</code> ：将输出文件的时长设置为第一个视频文件的时长，如果不设置，你会发现命令会一直执行根本不会停下来，因为gif图的循环是无限的</li></ul><p>这样gif图/短视频就会一直不停的播放了。</p><p>当然，如果希望水印播放一次就不播放了，那就设置上面的<code>eof_action</code>为<code>pass</code>就可以了，如下：<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie3.gif -filter_complex &quot;overlay=x=0:y=0:eof_action=pass&quot; out.mp4 -y</code></p><p>当然，如果视频一开始就播放且只播放一次，假如水印比较短可能根本就没被注意就过去了，这时可以设置水印出现的延迟时间，使用<code>-itsoffset</code>选项，如下：<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -itsoffset 3 -i doggie3.gif -filter_complex &quot;overlay=x=0:y=0:eof_action=pass&quot; out.mp4 -y</code><br>这样，视频播放3秒后，水印才会出现。</p><h2 id="水印显示时间变化"><a href="#水印显示时间变化" class="headerlink" title="水印显示时间变化"></a>水印显示时间变化</h2><h4 id="设置水印显示时长"><a href="#设置水印显示时长" class="headerlink" title="设置水印显示时长"></a>设置水印显示时长</h4><p><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=enable=&#39;lte(t,5)&#39;&quot; out.mp4 -y</code><br>上面命令作用是：让水印只显示5秒，5秒后消失。</p><h4 id="设置水印显示时间段"><a href="#设置水印显示时间段" class="headerlink" title="设置水印显示时间段"></a>设置水印显示时间段</h4><p><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=enable=&#39;between(t,5,10)&#39;&quot; out.mp4 -y</code><br>上面的命令作用是：让水印在视频的5~10秒时间段内显示</p><h4 id="设置两个水印轮番出现"><a href="#设置两个水印轮番出现" class="headerlink" title="设置两个水印轮番出现"></a>设置两个水印轮番出现</h4><p><code>ffmpeg -i big_buck_bunny.mp4 -i doggie1.png -i doggie2.png -filter_complex &quot;overlay=enable=&#39;lte(mod(t,10),4)&#39;,overlay=enable=&#39;gt(mod(t,10),6)&#39;&quot; out.mp4 -y</code><br>上面的命令作用是：第一个水印显示4秒后消失，2秒后第二个水印显示4秒后消失。<br>这里布置个作业？<img src="huaji.png" alt="huaji"> <strong>请让两个水印一个在左上角，一个在右上角</strong></p><h2 id="水印位置变化"><a href="#水印位置变化" class="headerlink" title="水印位置变化"></a>水印位置变化</h2><h4 id="设置水印随时间向右移动"><a href="#设置水印随时间向右移动" class="headerlink" title="设置水印随时间向右移动"></a>设置水印随时间向右移动</h4><p><code>ffmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi &quot;overlay=x=t*20&quot; -shortest out.mp4 -y</code><br>上面命令的作用是：让水印每秒向右移动20像素，直到消失。</p><h4 id="设置水印每隔10秒钟从左移动右直至消失"><a href="#设置水印每隔10秒钟从左移动右直至消失" class="headerlink" title="设置水印每隔10秒钟从左移动右直至消失"></a>设置水印每隔10秒钟从左移动右直至消失</h4><p><code> ffmpeg -i big_buck_bunny.mp4 -ignore_loop 0 -i doggie3.gif -lavfi &quot;overlay=enable=&#39;mod(t,10)&#39;:x=&#39;100*mod(t,10)-w&#39;&quot; -shortest out.mp4 -y</code><br>很实用很常见的水印展现方式有没有？<img src="huaji.png" alt="huaji">可以有效的防止别人盗视频并把水印去掉</p><p>这篇讲了三种水印活动的方式，下篇让水印转起来~<img src="huaji.png" alt="huaji"></p><h1 id="有问题请留言沟通，欢迎转载，转载请注明出处"><a href="#有问题请留言沟通，欢迎转载，转载请注明出处" class="headerlink" title="有问题请留言沟通，欢迎转载，转载请注明出处"></a>有问题请留言沟通，欢迎转载，转载请注明出处</h1><h1 id="博客地址：暖宝宝官方认证铲屎官"><a href="#博客地址：暖宝宝官方认证铲屎官" class="headerlink" title="博客地址：暖宝宝官方认证铲屎官"></a>博客地址：<a href="https://misland.github.io/">暖宝宝官方认证铲屎官</a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态分为三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;水印本身变化&lt;/li&gt;
&lt;li&gt;水印显示时间变化&lt;/li&gt;
&lt;li&gt;水印位置变化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;水印本身变化&quot;&gt;&lt;a href=&quot;#水印本身变化&quot; class=&quot;headerlink&quot; title=&quot;水印本身</summary>
      
    
    
    
    
    <category term="ffmpeg" scheme="https://misland.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg第3篇：为视频添加静态水印</title>
    <link href="https://misland.github.io/2021/02/23/ffmpeg-watermark-1/"/>
    <id>https://misland.github.io/2021/02/23/ffmpeg-watermark-1/</id>
    <published>2021-02-23T07:02:39.000Z</published>
    <updated>2021-02-23T08:06:31.996Z</updated>
    
    <content type="html"><![CDATA[<p>在ffmpeg中，添加水印需要用overlay滤镜，这是一个复杂滤镜，因为它需要两个输入，默认第一个输入是主画面，第二输入为水印，先执行一个简单的看看。<br>下面有两个文件，一个是可爱的大雄兔，一个是可爱的doggie，咱们就把doggie加到大雄兔上面去<br><img src="wm1.jpg" alt="wm1"><br>执行命令<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=x=0:y=0&quot; out.mp4 -y</code><br>这个命令的作用是在视频的左上角添加水印，命令中的x和y表示水印在视频中的位置，视频左上角坐标为(0,0)，向右向下延伸。<br><br>执行完成后，打开输出文件，效果如下<br><img src="wm2.jpg" alt="wm2"><br>是不是很简单？<img src="huaji.png" alt="huaji"><br>简单的看过了，下面来个稍微有一点点难度的<br></p><h4 id="如果要把水印加到右上角，怎么处理？"><a href="#如果要把水印加到右上角，怎么处理？" class="headerlink" title="如果要把水印加到右上角，怎么处理？"></a>如果要把水印加到右上角，怎么处理？</h4><p>可能有的小伙伴会说，先看看视频和图片的分辨率啊，然后算一下x，不就可以了？<br>这样当然是可以的，可是如果要批量处理不同分辨率的视频呢？这时再用上面的方法恐怕会累死人吧。<br>为了解决上面问题，再引入四个参数：</p><ul><li>main_w(W)：主画面的宽度</li><li>main_h(H)：主画面的高度</li><li>overlay_w(w)：水印宽度</li><li>overlay_h(h)：水印高度</li></ul><p>有了这四个参数，再来看上面的问题<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=x=W-w:y=0&quot; out.mp4 -y</code><br>上面的命令等效于<br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=x=main_w-overlay_w:y=0&quot; out.mp4 -y</code><br>执行后，看看输出文件<br><br><img src="wm3.jpg" alt="wm3"><br>咱们的小doggie跑到右上角去了。<br>有了上面的例子，那左下角、右下角怎么放聪明的小伙伴肯定知道了吧，就不啰嗦了。<br><br>这篇只是添加一个图片作为水印，现在的视频都不会这么简单了，通常都是动态的水印，或每隔一段时间出现一次，这种下篇再讲吧，一步步来。</p><h2 id="有问题请留言沟通，欢迎转载，转载请注明出处"><a href="#有问题请留言沟通，欢迎转载，转载请注明出处" class="headerlink" title="有问题请留言沟通，欢迎转载，转载请注明出处"></a>有问题请留言沟通，欢迎转载，转载请注明出处</h2><h2 id="博客地址：暖宝宝官方认证铲屎官"><a href="#博客地址：暖宝宝官方认证铲屎官" class="headerlink" title="博客地址：暖宝宝官方认证铲屎官"></a>博客地址：<a href="https://misland.github.io/">暖宝宝官方认证铲屎官</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在ffmpeg中，添加水印需要用overlay滤镜，这是一个复杂滤镜，因为它需要两个输入，默认第一个输入是主画面，第二输入为水印，先执行一个简单的看看。&lt;br&gt;下面有两个文件，一个是可爱的大雄兔，一个是可爱的doggie，咱们就把doggie加到大雄兔上面去&lt;br&gt;&lt;img</summary>
      
    
    
    
    
    <category term="ffmpeg" scheme="https://misland.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg第2篇：简单滤镜与复杂滤镜的区别</title>
    <link href="https://misland.github.io/2021/02/19/ffmpeg-filter/"/>
    <id>https://misland.github.io/2021/02/19/ffmpeg-filter/</id>
    <published>2021-02-19T08:33:40.000Z</published>
    <updated>2021-02-23T08:06:27.164Z</updated>
    
    <content type="html"><![CDATA[<p>在ffmpeg的滤镜中，有简单滤镜（simple filter）和复杂滤镜（complex filter）两种。<br><br>使用简单滤镜时，用<code>-vf</code>选项，使用复杂滤镜时，使用<code>-filter_complex</code>或<code>-lavfi</code>。<br>那么什么时候用简单滤镜，什么时候用复杂滤镜？<br><br>其实很简单：<strong>是否只有一个输入文件和一个输出文件，如果是，用简单滤镜，否，则应该用复杂滤镜</strong><br><br>执行一个命令试试<br><br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -lavfi &quot;overlay=x=50:y=50&quot; out.mp4 -y</code><br><br>上面的命令等效于<br><br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -filter_complex &quot;overlay=x=50:y=50&quot; out.mp4 -y</code><br><br>上面命令作用是给视频添左上角加一个水印，命令可以成功执行，打开输出文件可以看到doggie已经成功加上去了<br><br><img src="filter1.jpg" alt="filter1"><br>为了验证上面的结论，咱们把命令换成下面的<br><br><code>ffmpeg -hide_banner -i big_buck_bunny.mp4 -i doggie2.png -vf &quot;overlay=x=50:y=50&quot; out.mp4 -y</code><br><br>上面命令把<code>-filter_complex</code>换成了<code>-vf</code>，结果自然是会出错的，错误日志如下<br><br><img src="filter2.jpg" alt="filter error"><br>红框中的日志说的很清楚，<strong>对于简单滤镜，只能有一个输入输出</strong><br><br>所以，当有多个输入文件时，需要使用复杂滤镜。</p><h2 id="有问题请留言沟通，欢迎转载，转载请注明出处"><a href="#有问题请留言沟通，欢迎转载，转载请注明出处" class="headerlink" title="有问题请留言沟通，欢迎转载，转载请注明出处"></a>有问题请留言沟通，欢迎转载，转载请注明出处</h2><h2 id="博客地址：暖宝宝官方认证铲屎官"><a href="#博客地址：暖宝宝官方认证铲屎官" class="headerlink" title="博客地址：暖宝宝官方认证铲屎官"></a>博客地址：<a href="https://misland.github.io/">暖宝宝官方认证铲屎官</a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在ffmpeg的滤镜中，有简单滤镜（simple filter）和复杂滤镜（complex filter）两种。&lt;br&gt;&lt;br&gt;使用简单滤镜时，用&lt;code&gt;-vf&lt;/code&gt;选项，使用复杂滤镜时，使用&lt;code&gt;-filter_complex&lt;/code&gt;或&lt;code&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ffmpeg第1篇：日志级别控制、保存日志到指定文件、处理进度查询</title>
    <link href="https://misland.github.io/2021/02/18/ffmpeg-log/"/>
    <id>https://misland.github.io/2021/02/18/ffmpeg-log/</id>
    <published>2021-02-18T08:14:00.000Z</published>
    <updated>2021-02-23T08:06:22.493Z</updated>
    
    <content type="html"><![CDATA[<p>ffmpeg默认就会输出一些日志，包含编译的工具（gcc版本）、可用的组件（–enable-xxxx）、组件版本号码，如下图<br><img src="1.jpg" alt="log"></p><a id="more"></a><p>这些信息是默认输出的，每次执行合作都会打印在控制台中，如果不想看这些信息，ffmpeg提供了<code>-hide_banner</code>选项，添加该选项后，即不会打印这些信息<br>而在执行日志层面，ffmpeg日志与通用日志一致，也有级别的概念，可以使用<code>-v</code>选项来控制，设置级别时，可以使用英文单词，也可以使用数字，具体的级别如下</p><h3 id="debug-48"><a href="#debug-48" class="headerlink" title="debug 48"></a>debug 48</h3><p>即debug级别的日志，在ffmpeg中使用48来标记，该级别会打印全部的日志，执行一个命令试试<br><code>ffmpeg -v debug -i 3.mp4 -vf scale=192x108 out.mp4 -y</code><br>该命令等效于<br><code>ffmpeg -v 48 -i 3.mp4 -vf scale=192x108 out.mp4 -y</code><br>执行命令后，控制台输出日志如下<br><img src="2.jpg" alt="debug_log"><br>上面的命令，将视频压缩成190x108分辨率的视频，使用了<code>-vf</code>选项，可以看到红框中的信息，将命令执行时的步骤很详细的打印了出来。</p><h3 id="verbose-40"><a href="#verbose-40" class="headerlink" title="verbose 40"></a>verbose 40</h3><p>比debug日志简略一些，上面的命令同样再执行一次，上图红框中的信息就不再打印了</p><h3 id="info-32"><a href="#info-32" class="headerlink" title="info 32"></a>info 32</h3><p>与verbose相似，显示的日志会稍微少些，这也是ffmpeg默认使用的日志级别</p><h3 id="warning-24"><a href="#warning-24" class="headerlink" title="warning 24"></a>warning 24</h3><p>只显示warning或更严重的日志</p><h3 id="error-16"><a href="#error-16" class="headerlink" title="error 16"></a>error 16</h3><p>只显示错误或更严重的日志</p><h3 id="fatal-8"><a href="#fatal-8" class="headerlink" title="fatal 8"></a>fatal 8</h3><p>只显示致命错误，一般出现这些错误，程序会退出</p><h3 id="panic-0"><a href="#panic-0" class="headerlink" title="panic 0"></a>panic 0</h3><p>只显示程序崩溃的日志，这种一般是ffmpeg内部的错误了，一般二般情况下应该都不会遇到的</p><h3 id="quiet-8"><a href="#quiet-8" class="headerlink" title="quiet -8"></a>quiet -8</h3><p>什么也不显示，包括错误信息，生产环境通常并不会这么做，除非你疯了🤣<br>以上是控制日志打印级别，有时需要将日志保存下来，以备出现问题时定位问题，这时可以使用<code>- report</code>命令，将日志保存到文件中，执行命令<code>ffmpeg -report -i 3.mp4 -vf scale=192x108 out.mp4 -y</code>，执行后文件夹中出现了一个日志文件<br><img src="3.jpg" alt="report_log"><br>打开文件后，发现输出的日志与verbose级别一致。<br>但是这种方式文件名是ffmpeg根据时间默认生成的，如果要指定文件名可以吗？答案当然是肯定的，执行命令<br><code>FFREPORT=file=ffreport.log:level=32 ffmpeg -i 3.mp4 -vf scale=192x108 out.mp4 -y</code><br>成功执行后，会发现文件夹下多了一个名为ffreport.log的文件，即指定生成的日志文件</p><h2 id="监控处理进度"><a href="#监控处理进度" class="headerlink" title="监控处理进度"></a>监控处理进度</h2><p>有时可能会想知道当前处理的进度，这时可以使用<code>-progress</code>选项，执行命令如下<br><code>ffmpeg -progress pro.log -i big_buck_bunny.mp4 -vf scale=192x108 out.mp4 -y</code><br>成功执行后，会有一个pro.log文件，打开后如下<br><img src="4.jpg" alt="progress_log"><br>有了这些信息，就可以了解当前处理的进度，可以做一些人性化的功能。</p><h2 id="有问题请留言沟通，欢迎转载，转载请注明出处"><a href="#有问题请留言沟通，欢迎转载，转载请注明出处" class="headerlink" title="有问题请留言沟通，欢迎转载，转载请注明出处"></a>有问题请留言沟通，欢迎转载，转载请注明出处</h2><h2 id="博客地址：暖宝宝官方认证铲屎官"><a href="#博客地址：暖宝宝官方认证铲屎官" class="headerlink" title="博客地址：暖宝宝官方认证铲屎官"></a>博客地址：<a href="https://misland.github.io/">暖宝宝官方认证铲屎官</a></h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;ffmpeg默认就会输出一些日志，包含编译的工具（gcc版本）、可用的组件（–enable-xxxx）、组件版本号码，如下图&lt;br&gt;&lt;img src=&quot;1.jpg&quot; alt=&quot;log&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="ffmpeg" scheme="https://misland.github.io/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>springboot源码解析-@RequestMapping是怎么工作的</title>
    <link href="https://misland.github.io/2020/12/01/handlerMapping/"/>
    <id>https://misland.github.io/2020/12/01/handlerMapping/</id>
    <published>2020-12-01T07:35:21.000Z</published>
    <updated>2020-12-03T03:16:11.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="絮叨几句"><a href="#絮叨几句" class="headerlink" title="絮叨几句"></a>絮叨几句</h2><p>这是一篇探究源码的文章，想学习一下优秀框架的设计思路，spring的功能太多了，一下子就看完也不可能，也没那个能力，这里就以springMVC中路由映射注解@RequestMapping为切入点，看它是怎么工作的。<br><br>学习源码时，方法很重要！！！不建议直接打开源码自己闷头看，这样会很浪费时间，你需要先理清作者的设计思路，再一点点的看明白，会很浪费时间，如果有其它大佬写过你想学习的点，那你完全可以先看下TA的文章，先了解一下大致的结构，再带着自己的疑问，去看源码，这样会事半功倍的，我这篇文章便是如此，全程参观了<a href="https://www.jianshu.com/p/3a56ae288ee5">简书-有点胖的小乐乐</a>写的分析文章，再结合源码调试来学习。<br><br>每个人的思路都是不一样的，前面大佬写的挺棒，但是我看的时候是比较吃力的，因为和我的思路差别太大，并且我觉得后面复习时很困难，所以才又写了一篇。前面也说了，学习时要带着问题，不然都没有目的那会很迷茫，不知道到底应该看哪里，所以通篇会以问题的形式递进，从开始一步步去探索源码，为了能说的清楚点，代码贴的比较多，篇幅有点长，如果你只想知道流程，那看完问题4就可撤了😀😀😀，后面只是更一步探索而已 ，并不会帮助你解决实际问题，所以。。。看个人需求吧<br>调试和源码出自：</p><ul><li>idea 2019.2</li><li>springboot v2.0.0</li><li>spring-web v5.0.4</li><li>spring-webmvc v5.0.4<br>学习时建议使用相同版本，因为项目是在不停维护更新的，版本不同可能处理流程会有不同。</li></ul><h2 id="问题1：springboot为什么能开箱即用MVC"><a href="#问题1：springboot为什么能开箱即用MVC" class="headerlink" title="问题1：springboot为什么能开箱即用MVC?"></a>问题1：springboot为什么能开箱即用MVC?</h2><p>答：因为springboot在APP启动时，自动为我们配置了MVC需要的配置<br><br>在<code>org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</code>有如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatcherServlet <span class="title">dispatcherServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  DispatcherServlet dispatcherServlet = <span class="keyword">new</span> DispatcherServlet();</span><br><span class="line">  dispatcherServlet.setDispatchOptionsRequest(</span><br><span class="line">      <span class="keyword">this</span>.webMvcProperties.isDispatchOptionsRequest());</span><br><span class="line">  dispatcherServlet.setDispatchTraceRequest(</span><br><span class="line">      <span class="keyword">this</span>.webMvcProperties.isDispatchTraceRequest());</span><br><span class="line">  dispatcherServlet.setThrowExceptionIfNoHandlerFound(</span><br><span class="line">      <span class="keyword">this</span>.webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class="line">  <span class="keyword">return</span> dispatcherServlet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springboot在这里new了一个DispatcherServlet类的实例，这个类都很熟悉，它位于spring-webmvc package中，是用来处理http请求的，这样APP就有了处理http请求的能力。<br><br>对于MVC应用，还要初始化MVC配置，springboot提供了一个<code>org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</code>类，在这个类中完成了MVC需要的配置，springboot之所以能直接运行MVC APP，原因就在这里。</p><h2 id="问题2：如何根据Url找到对应的Controller处理请求？"><a href="#问题2：如何根据Url找到对应的Controller处理请求？" class="headerlink" title="问题2：如何根据Url找到对应的Controller处理请求？"></a>问题2：如何根据Url找到对应的Controller处理请求？</h2><p>答：前面说过，DispatcherServlet是处理所有请求的入口，具体方法是doDispatch，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Process the actual dispatching to the handler.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;The handler will be obtained by applying the servlet&#x27;s HandlerMappings in order.</span></span><br><span class="line"><span class="comment">  * The HandlerAdapter will be obtained by querying the servlet&#x27;s installed HandlerAdapters</span></span><br><span class="line"><span class="comment">  * to find the first that supports the handler class.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;All HTTP methods are handled by this method. It&#x27;s up to HandlerAdapters or handlers</span></span><br><span class="line"><span class="comment">  * themselves to decide which methods are acceptable.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> Exception in case of any kind of processing failure</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  .....</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">      <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">      mappedHandler = getHandler(processedRequest);</span><br><span class="line">      <span class="comment">//省略</span></span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      <span class="comment">//省略</span></span><br><span class="line">      .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上面的注释并不难理解，都是很简单的英文，简单来说就是该方法是真正将请求映射到对应handler，handler是实现了HandlerMappings接口的实例，程序会去轮询已经注册过的handler，从而找到合适的handler来处理请求。<br><br>那接下来看getHandler是如何实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (HandlerMapping hm : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">      <span class="comment">//省略</span></span><br><span class="line">      .....</span><br><span class="line">      HandlerExecutionChain handler = hm.getHandler(request);</span><br><span class="line">      <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面注释中所述，这里轮询了注册过的HandlerMapping实例，分别调用getHandler方法，尝试找到合适的handler，咱们都知道开发MVC APP时用@ReauestMapping注解标注方法响应什么Url，调试下来，会发现，在IOC容器中已经注册了多个HandlerMapping的实现类，如下图</p><div align=center><p><img src="1.jpg" alt="1"></p></div>最终会在调用RequestMappingHandlerMapping实例的getHandler方法，找到了处理的handler，调试信息如下图<br><div align=center><p><img src="5.jpg" alt="5"></p></div>可以看到，RequestMappingHandlerMapping成功根据请示的Url，找到了可以处理的Controller和对应的方法。到了这里，根据Url找Controller的问题解决了，但是又产生了两个新问题<br>1. RequestMappingHandlerMapping是什么时候注册进来的？看问题3<br>2. RequestMappingHandlerMapping的getHandler又是怎么处理的？看问题4<h2 id="问题3：RequestMappingHandlerMapping是怎么注册的呢？"><a href="#问题3：RequestMappingHandlerMapping是怎么注册的呢？" class="headerlink" title="问题3：RequestMappingHandlerMapping是怎么注册的呢？"></a>问题3：RequestMappingHandlerMapping是怎么注册的呢？</h2><p>答：在第一个问题中，说过springboot通过WebMvcAutoConfiguration完成了MVC的配置，从而能处理MVC请求。<br><br>而在该类中，存在一个静态类<code>public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration</code>，这个静态类有如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Must be @Primary for MvcUriComponentsBuilder to work</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.requestMappingHandlerMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个方法使用注解@Bean标，在APP启动时，IOC容器会扫描并创建实例将其加载到容器中以备使用，由于这里调用的父类DelegatingWebMvcConfiguration的方法，所以再去看这个类继承的类，位于<code>spring-webmvc</code>package中，具体位置为<code>org.springframework.web.servlet.config.annotation.DelegatingWebMvcConfiguration</code>，然而DelegatingWebMvcConfiguration这个类并没有该方法，不过该类继承了<code>org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport</code>类，所以咱们继续找，果然WebMvcConfigurationSupport类中有具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title">requestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  RequestMappingHandlerMapping mapping = createRequestMappingHandlerMapping();</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mapping;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RequestMappingHandlerMapping <span class="title">createRequestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestMappingHandlerMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到new了一个RequestMappingHandlerMapping出来，继而通过@Bean注解提供给了IOC容器，所以到这里咱们知道springboot中如何初始化RequestMappingHandlerMapping了，接下来要看问题2最后三个问题中的第二个了，RequestMappingHandlerMapping是如何获得handler的。<br></p><h2 id="问题4：RequestMappingHandlerMapping的getHandler怎么工作的？"><a href="#问题4：RequestMappingHandlerMapping的getHandler怎么工作的？" class="headerlink" title="问题4：RequestMappingHandlerMapping的getHandler怎么工作的？"></a>问题4：RequestMappingHandlerMapping的getHandler怎么工作的？</h2><p>答：RequestMappingHandlerMapping中并没有getHandler的实现，具体的代码是在其继承的抽象类<code>org.springframework.web.servlet.handler.AbstractHandlerMapping</code>中，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Object handler = getHandlerInternal(request);</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  .....</span><br><span class="line">  <span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知AbstractHandlerMapping调用了getHandlerInternal方法，而getHandlerInternal方法的实现在<code>org.springframework.web.servlet.handler.AbstractHandlerMethodMapping</code>中（这里插一句，抽象类的设计结构很棒有木有，先是一个顶层的handlerMapping映射Controller，再是一个继承了该类的寻找方法的AbstractHandlerMethodMapping，层层往下，不同层次的功能，通过不同抽象类进行分割，都可以让开发者自定义，佩服），代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  .....</span><br><span class="line">  <span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看变量名字就比较好理解，先从request中找到路径，根据路径匹配对应的controller和method，调试截图如下</p><div align=center><p><img src="3.jpg" alt="3"></p></div><p>可以看到，根据路径“/hello/test”定位到了HelloController中的test方法，找到了处理请求的方法，后面的流程就是调用该方法，处理请求，进而返回响应结果，比如在测试代码中，/hello/test返回的是一个jsp模板，执行完test方法后会返回ResourceHttpRequestHandler对象，由浏览器渲染html页面。<br>到这里，其实已经知道springMVC通过url映射Controller处理请求的流程了，如果只想知道处理流程的童鞋，可以ctrl+w了。😂 😂 😂 <br><br>不过如果有足够的好奇心，可能还会有下面的问题</p><h1 id="问题5：在哪里找到的对应的Controller和method的呢？"><a href="#问题5：在哪里找到的对应的Controller和method的呢？" class="headerlink" title="问题5：在哪里找到的对应的Controller和method的呢？"></a>问题5：在哪里找到的对应的Controller和method的呢？</h1><p>答：在APP启动时，springboot已经遍历扫描了所有注册的Controller，进而扫描到所有定义的路径，存储到集合中，所以当请求到达时，可以直接从已经存在的集合中找到对应的Controller和method<br>还是看源码，咱们看AbstractHandlerMethodMapping中定义的getHandlerInternal方法，这个方法中，又调用了lookupHandlerMethod寻找处理请示的method，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line">  <span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">    addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//省略</span></span><br><span class="line">    .....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，根据请求路径“/hello/test”去mappingRegistry中匹配对应的handler，调试发现mappingRegistry信息如下</p><div align=center><p><img src="6.jpg" alt="6"></p></div><p>是不是清楚明了呢，咱们通过@RequestMapping注解标注的路径都在这里面存过了，那mappingRegistry是什么呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MappingRegistry mappingRegistry = <span class="keyword">new</span> MappingRegistry();</span><br></pre></td></tr></table></figure><p>mappingRegistry是AbstractHandlerMethodMapping中MappingRegistry的实例，因为AbstractHandlerMethodMapping实现了InitializingBean接口，实现了该接口的类在实例化时，spring会自动调用afterPropertiesSet方法，具体的原理，请参考博客园网友的作品（<a href="https://www.cnblogs.com/study-everyday/p/6257127.html">传送门</a>）<br><br>AbstractHandlerMethodMapping实现的afterPropertiesSet代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看initHandlerMethods的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略</span></span><br><span class="line">  .....</span><br><span class="line">  String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">      BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">      obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">      Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">        .....</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">        detectHandlerMethods(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Look for handler methods in a handler.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler the bean name of a handler or a handler instance</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</span><br><span class="line">  Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">      obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">    Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">        (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//省略</span></span><br><span class="line">            .....</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="comment">//省略</span></span><br><span class="line">      .....</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">      Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">      T mapping = entry.getValue();</span><br><span class="line">      registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>initHandlerMethods方法中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = (<span class="keyword">this</span>.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">    BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">    obtainApplicationContext().getBeanNamesForType(Object.class));</span><br></pre></td></tr></table></figure><p>获取IOC容器中注册的对象，咱们程序中的类也在其中，看下图</p><div align=center><p><img src="8.png" alt="8"></p></div><p>之后会轮询这些对象，判断其是否为处理请求的handler类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">    detectHandlerMethods(beanName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果是，则在detectHandlerMethods中用反射的方式获取类信息，如方法和方法注解这些，根据咱们标注的@RequestMapping，将Url与method，并将其注册到mappingRegistry对应的集合中，所以就如在问题2所述中，当http请求到来时，springMVC就可以根据Url来找到对应的Controller和method，处理和响应请求。<br>好了，到这里我觉得可以结束了，篇幅挺长的，如果你看到了这里，那请接受我的敬意，真的很有毅力，希望能一起进步，用知识武装自己，让自己变得更好更强大💪<br>参考文章<a href="https://www.jianshu.com/p/3a56ae288ee5">简书-有点胖的小乐乐</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;絮叨几句&quot;&gt;&lt;a href=&quot;#絮叨几句&quot; class=&quot;headerlink&quot; title=&quot;絮叨几句&quot;&gt;&lt;/a&gt;絮叨几句&lt;/h2&gt;&lt;p&gt;这是一篇探究源码的文章，想学习一下优秀框架的设计思路，spring的功能太多了，一下子就看完也不可能，也没那个能力，这里就以</summary>
      
    
    
    
    <category term="java" scheme="https://misland.github.io/categories/java/"/>
    
    
    <category term="Springboot" scheme="https://misland.github.io/tags/Springboot/"/>
    
    <category term="Spring" scheme="https://misland.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>使用Idea新建Springboot项目，整合jsp</title>
    <link href="https://misland.github.io/2020/11/30/20201127/"/>
    <id>https://misland.github.io/2020/11/30/20201127/</id>
    <published>2020-11-30T03:09:41.000Z</published>
    <updated>2020-12-01T07:36:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看杨开振的《深入浅出springboot2.x》这本书，看到SpringMVC这两章时，就想建个demo试试，他用的是jsp作模板，这个东西现在基本是被淘汰了的，不过学习嘛，用这个来了解一下spring的工作流程还是可以的，结果在建项目时遇到了点坑，这里记录下</p><h2 id="问题1：springboot集成jsp需要哪些package？"><a href="#问题1：springboot集成jsp需要哪些package？" class="headerlink" title="问题1：springboot集成jsp需要哪些package？"></a>问题1：springboot集成jsp需要哪些package？</h2><p>答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-embed-jasper&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>测试下来，只要上面两个package即可，测试了多个springboot多个版本（2.0.0-2.3.6），只要加了上面两个package都是可以正常解析jsp模板的<br><br><strong>注意：package引入时不要加scope-&gt;provided选项，否则可能会因为idea设置导致无法使用问题，如果你遇到了这个问题，也可以参考这里（<a href="https://blog.csdn.net/qq_43123875/article/details/82351985">传送门</a>）尝试解决</strong></p><a id="more"></a><h2 id="问题2：怎么让让jsp文件目录融入到项目中？"><a href="#问题2：怎么让让jsp文件目录融入到项目中？" class="headerlink" title="问题2：怎么让让jsp文件目录融入到项目中？"></a>问题2：怎么让让jsp文件目录融入到项目中？</h2><p>答：用spring initializer的模板初始化的项目，是没有传统的webapp文件夹的，即使你勾选了web模块，项目初始目录应该是没有下面的webapp文件夹的<br><br><img src="1.jpg" alt="init"><br><br>解决办法就是手动创建一个Directory😂，但是创建完会发现文件夹图标与上面图片中不一样，没有那个小圆点图标<br><br><img src="2.jpg" alt="create"><br><br>这是因为这时项目还没有将这个文件夹认为是存放web资源文件的地方，这时可以右键项目名称，在菜单中找到下面的Open Module Settings选项<br><br><img src="3.jpg" alt="module"><br><br>在弹出的窗口中（Modules-&gt;项目名称-&gt;Web）设置Web Resource Directory，如下图<br><br><img src="4.jpg" alt="settings"><br><br>点击1处的加号，在弹出框中2那里将目录设置成刚才添加的webapp文件夹，确定后，就能看到webapp文件夹变成有小圆点图标的样子了，<strong>并且此时右键webapp文件夹新建文件时会有JSP/JSPX选项</strong><br><br><strong>注意，此时只是在idea中设置好了，但是sprinMVC并不知道去哪里找jsp模板，还要在application.properties文件中添加下面两行代码才行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.prefix&#x3D;&#x2F;WEB-INF&#x2F;jsp&#x2F;</span><br><span class="line">spring.mvc.view.suffix&#x3D;.jsp</span><br></pre></td></tr></table></figure><h2 id="问题3：怎么设置路由？怎么返回页面？"><a href="#问题3：怎么设置路由？怎么返回页面？" class="headerlink" title="问题3：怎么设置路由？怎么返回页面？"></a>问题3：怎么设置路由？怎么返回页面？</h2><p>答：springMVC中已经为我们做了很多东西，并不需要我们写太多东西，可以建个HelloController文件，加入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;test&quot;)</span><br><span class="line">    public String test() &#123;</span><br><span class="line">        return &quot;hello&#x2F;test&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;test2&quot;)</span><br><span class="line">    public ModelAndView test2() &#123;</span><br><span class="line">        ModelAndView mv &#x3D; new ModelAndView();</span><br><span class="line">        mv.setViewName(&quot;hello&#x2F;test2&quot;);</span><br><span class="line">        return mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在webapp下创建jsp文件，目录如下<br><br><img src="5.jpg" alt="directory"><br><br>上面设置了两个路由，一个直接返回String，一个返回的是一个ModelAndView，都可以在前端正常渲染页面，之所以这样是springMVC内部做了很多处理，详细的不在这里说了，这里只是记录环境搭建。<br><br><a href="https://gitee.com/loki-test/springboot-jsp">gitee测试代码</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在看杨开振的《深入浅出springboot2.x》这本书，看到SpringMVC这两章时，就想建个demo试试，他用的是jsp作模板，这个东西现在基本是被淘汰了的，不过学习嘛，用这个来了解一下spring的工作流程还是可以的，结果在建项目时遇到了点坑，这里记录下&lt;/p&gt;
&lt;h2 id=&quot;问题1：springboot集成jsp需要哪些package？&quot;&gt;&lt;a href=&quot;#问题1：springboot集成jsp需要哪些package？&quot; class=&quot;headerlink&quot; title=&quot;问题1：springboot集成jsp需要哪些package？&quot;&gt;&lt;/a&gt;问题1：springboot集成jsp需要哪些package？&lt;/h2&gt;&lt;p&gt;答：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;org.apache.tomcat.embed&amp;lt;&amp;#x2F;groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;tomcat-embed-jasper&amp;lt;&amp;#x2F;artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;&amp;#x2F;groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;jstl&amp;lt;&amp;#x2F;artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&amp;#x2F;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;测试下来，只要上面两个package即可，测试了多个springboot多个版本（2.0.0-2.3.6），只要加了上面两个package都是可以正常解析jsp模板的&lt;br&gt;&lt;br&gt;&lt;strong&gt;注意：package引入时不要加scope-&amp;gt;provided选项，否则可能会因为idea设置导致无法使用问题，如果你遇到了这个问题，也可以参考这里（&lt;a href=&quot;https://blog.csdn.net/qq_43123875/article/details/82351985&quot;&gt;传送门&lt;/a&gt;）尝试解决&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://misland.github.io/categories/java/"/>
    
    
    <category term="Springboot" scheme="https://misland.github.io/tags/Springboot/"/>
    
    <category term="Spring" scheme="https://misland.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>使用Systemback制做Ubuntu18.04镜像</title>
    <link href="https://misland.github.io/2020/11/09/ubuntu-systemback/"/>
    <id>https://misland.github.io/2020/11/09/ubuntu-systemback/</id>
    <published>2020-11-09T09:10:04.000Z</published>
    <updated>2020-11-10T03:16:44.757Z</updated>
    
    <content type="html"><![CDATA[<p>最近因工作需要，想制做Ubuntu Desktop 18.04版本的系统镜像，在网上看了下SystemBack这个工具还不错，就试了下，试了下确实好用，不过有些问题还是需要注意一下的，并且这个工具还原时需要手动设置挂载点，这个对于不熟悉Linux的童鞋来说，可能还真有点坑，所以这里记录一下使用过程吧<br><br>here wo go！！！😜<br></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>  这个工具没有18.04的源了，只能用16.04的，但是CSDN上很多教程都不提这一点，只是无脑的抄了别人的文章，我刚开始时就被坑了，按照CSDN上的一些垃圾教程，直接添加了18.04的ppa，结果后面安装时失败，各种问题，下面是正确的安装方式<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">&quot;deb http://ppa.launchpad.net/nemh/systemback/ubuntu xenial main&quot;</span></span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 382003C2C8B7B4AB813E915B14E4942973C62A1B</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install systemback</span><br></pre></td></tr></table></figure><p>如果你没遇到问题，那恭喜你已经安装成功了，可以继续看下面的使用部分了，如果失败那请搜索错误原因吧，因为我按照上面的方式装过好几次都是正常的😉<br>  如果已经看了垃圾教程，装了ppa，就要先删除<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository --remove ppa:nemh&#x2F;systemback</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>安装完在程序列表中就可以看到Systemback了，点击打开会看到下面的界面<br><br><img src="1.png" alt="start"><br><br>如上图，点击Live system create，之后进到下面界面<br><img src="2.png" alt="start"><br><br>左上角的Working directory(工作目录)其实就是存放镜像文件路径，设成想放的路径就好，至于下面的镜像名字自己定义就好，设置完点Crate new开始制作（我这一步遇到个坑，装系统时磁盘空间设置太小，空间不够，无法备份，最后用GParted，给系统盘增加了空间才成功，当然这是自己犯蠢，与软件无关😅）<br></p><p>接下来就是等待备份完成了，趁机去喝口茶或抽支烟啥的<del>~</del><br><br><img src="3.png" alt="start"><br><br>如上，备份成功后若你插入的有U盘可以点击Write to target将备份SBLIVE写入U盘，这样这个U盘就会变成启动盘，可以直接启动了（用下来发现好像只能将SBLIVE写入，ISO文件是无法写入的）<br></p><p>也可以点击Convert to ISO,将SBLIVE转成ISO，iso文件存放路径就在上面说的Working directory下，有了iso如何处理就自己尝试吧~</p><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><p>把U盘插入要还原电脑，设置U盘启动，进去后会有下面界面<br><img src="4.png" alt="start"><br></p><p>第一个是进入live system，这个是啥意思呢，其实就是进入备份时的系统状态，当时是啥样，进去后就啥样，但是这时系统并没有还原到电脑，退出就没了，进入系统后，再次打开软件，点击上面第一张图中的system install，可进入安装页面(我制做的U盘，启动后第二个菜单显示的是Boot System Installer，与上图中有所不同，选择这个能直接进入系统还原页面，比较方便)<br></p><p><img src="6.png" alt="user"><br></p><p>这里设置用户名、密码等，没啥可说的，自行设置吧，设置完点击下一步，进入下面页面<br><br></p><p><img src="5.png" alt="start"><br><br>如上图，这里是设置挂载点页面，具体操作方法如下：</p><ol><li>选中要安装系统的硬盘，点右边的卸载/delete!，将其卸载</li><li>/、/home、swap、/boot/efi这四个挂载点是必须要设置的，选中要挂载的硬盘，右边会出现一个文本框，让你输入分割的大小，这里根据自己的硬盘大小，酌情分配，数字设置完毕点击下面的箭头即可，建议的分割大小是<ol><li>先分配swap，大小与内存相当即可</li><li>再分配boot/efi，大小200m即可</li><li>最后分配/和/home，文件系统都选ext4即可，/与/home的大小比一般是1:10到3:10，看个人需求而定。</li></ol></li><li>上面四个挂载点分割完毕后，进行挂载，先选中上一步分割的硬盘，在“挂载点”下拉列表中选择要挂载的目的即可，挂载/boot/efi时你可能会发现下拉列表中没有，直接在文件框中输入这个就好了😂<br></li></ol><h2 id="注意下面的选项"><a href="#注意下面的选项" class="headerlink" title="注意下面的选项"></a>注意下面的选项</h2><ul><li>传递用户配置文件：选中后用户家目录里面的文件都会一并还原，不选择不会还原</li><li>安装GRUB2引导程序，不能点禁用，上图说要将挂载点设为/boot/efi，但是我还原了两次，有一次是我加完/boot/efi后，这个自动变成了EFI，另一次却没有，没有的话选择你要将系统还原的硬盘，也是可以成功还原的</li></ul><p>设置完成后，点击下一步再次静静等待吧~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因工作需要，想制做Ubuntu Desktop 18.04版本的系统镜像，在网上看了下SystemBack这个工具还不错，就试了下，试了下确实好用，不过有些问题还是需要注意一下的，并且这个工具还原时需要手动设置挂载点，这个对于不熟悉Linux的童鞋来说，可能还真有点坑，所以这里记录一下使用过程吧&lt;br&gt;&lt;br&gt;here wo go！！！😜&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;  这个工具没有18.04的源了，只能用16.04的，但是CSDN上很多教程都不提这一点，只是无脑的抄了别人的文章，我刚开始时就被坑了，按照CSDN上的一些垃圾教程，直接添加了18.04的ppa，结果后面安装时失败，各种问题，下面是正确的安装方式&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository &lt;span class=&quot;string&quot;&gt;&amp;quot;deb http://ppa.launchpad.net/nemh/systemback/ubuntu xenial main&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 382003C2C8B7B4AB813E915B14E4942973C62A1B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install systemback&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你没遇到问题，那恭喜你已经安装成功了，可以继续看下面的使用部分了，如果失败那请搜索错误原因吧，因为我按照上面的方式装过好几次都是正常的😉&lt;br&gt;  如果已经看了垃圾教程，装了ppa，就要先删除&lt;br&gt;  &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository --remove ppa:nemh&amp;#x2F;systemback&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://misland.github.io/categories/Linux/"/>
    
    
    <category term="Ubuntu" scheme="https://misland.github.io/tags/Ubuntu/"/>
    
    <category term="系统" scheme="https://misland.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Couldn&#39;t get file path for photo on ANDROID 10</title>
    <link href="https://misland.github.io/2020/11/03/android-camera/"/>
    <id>https://misland.github.io/2020/11/03/android-camera/</id>
    <published>2020-11-03T01:04:55.000Z</published>
    <updated>2021-02-18T09:58:23.714Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在使用RN的react-native-image-picker（v2.3.4）组件时遇到了一个问题，通过yarn添加组件后，根据文档导入变量并调用相机拍照</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ImagePicker <span class="keyword">from</span> <span class="string">&#x27;react-native-image-picker&#x27;</span>;</span><br><span class="line">cameraOperation() &#123;</span><br><span class="line">    <span class="keyword">const</span> options = &#123;</span><br><span class="line">      title: <span class="string">&#x27;Take a photo&#x27;</span>,</span><br><span class="line">      <span class="comment">//自定义按钮，目前没发现有什么用</span></span><br><span class="line">      customButtons: [&#123; <span class="attr">name</span>: <span class="string">&#x27;fb&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Choose photo from Facebook&#x27;</span> &#125;],</span><br><span class="line">      storageOptions: &#123;</span><br><span class="line">        skipBackup: <span class="literal">true</span>,</span><br><span class="line">        path: <span class="string">&#x27;images&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ImagePicker.showImagePicker(options, <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//path：图片的存储路径</span></span><br><span class="line">      <span class="comment">//uri：在当前app内的存储路径</span></span><br><span class="line">      <span class="comment">//width、height：拿到的图片的宽高</span></span><br><span class="line">      <span class="comment">//data：图片的base64格式数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Response = &#x27;</span>, response);</span><br><span class="line">      <span class="keyword">if</span> (response.didCancel) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;User cancled image picker&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (response.error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;ImagePicker error:&#x27;</span>, response.error);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (response.customButton) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;User tapped custom button:&#x27;</span>, response.customButton);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(response.uri);</span><br><span class="line">        <span class="keyword">const</span> source = &#123; <span class="attr">uri</span>: response.uri &#125;;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; <span class="attr">avatarSource</span>: source &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然而在运行时，却抛出了标题所述的错误，开始不得其解，后来搜索了一下资料，原来是因为API29的原因，API29对应的安卓版本是Android10，而Android中引入了分区存储（Scoped storage）的概念，这样做的初衷是为了避免APP乱写文件从而产生很多乱七八糟的冗余文件，更好的保护用户数据，具体的介绍可以看这里（<a href="https://juejin.im/post/6844904063432130568">传送门</a>）<br></p><a id="more"></a><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>修改AndroidManifest.xml文件<br>我用的RN版本是0.63.3，react-native-cli的版本是4.13.0，项目是用react-native-cli来init的，AndroidManifest.xml路径在android/app/src/main下，在application标签中，添加<br><code>android:requestLegacyExternalStorage =&quot;true&quot;</code><br>属性，即可正常调用摄像头并拍照~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天在使用RN的react-native-image-picker（v2.3.4）组件时遇到了一个问题，通过yarn添加组件后，根据文档导入变量并调用相机拍照&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ImagePicker &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;#x27;react-native-image-picker&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cameraOperation() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; options = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      title: &lt;span class=&quot;string&quot;&gt;&amp;#x27;Take a photo&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//自定义按钮，目前没发现有什么用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      customButtons: [&amp;#123; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;fb&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;title&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&amp;#x27;Choose photo from Facebook&amp;#x27;&lt;/span&gt; &amp;#125;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      storageOptions: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        skipBackup: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        path: &lt;span class=&quot;string&quot;&gt;&amp;#x27;images&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ImagePicker.showImagePicker(options, &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;response&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//path：图片的存储路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//uri：在当前app内的存储路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//width、height：拿到的图片的宽高&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;//data：图片的base64格式数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;Response = &amp;#x27;&lt;/span&gt;, response);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (response.didCancel) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;User cancled image picker&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (response.error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(&lt;span class=&quot;string&quot;&gt;&amp;#x27;ImagePicker error:&amp;#x27;&lt;/span&gt;, response.error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (response.customButton) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;User tapped custom button:&amp;#x27;&lt;/span&gt;, response.customButton);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(response.uri);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; source = &amp;#123; &lt;span class=&quot;attr&quot;&gt;uri&lt;/span&gt;: response.uri &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;this&lt;/span&gt;.setState(&amp;#123; &lt;span class=&quot;attr&quot;&gt;avatarSource&lt;/span&gt;: source &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而在运行时，却抛出了标题所述的错误，开始不得其解，后来搜索了一下资料，原来是因为API29的原因，API29对应的安卓版本是Android10，而Android中引入了分区存储（Scoped storage）的概念，这样做的初衷是为了避免APP乱写文件从而产生很多乱七八糟的冗余文件，更好的保护用户数据，具体的介绍可以看这里（&lt;a href=&quot;https://juejin.im/post/6844904063432130568&quot;&gt;传送门&lt;/a&gt;）&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="https://misland.github.io/categories/Android/"/>
    
    
    <category term="React Native" scheme="https://misland.github.io/tags/React-Native/"/>
    
  </entry>
  
</feed>
